# 1. 클래스와 프로토타입
- factory 함수 : 클래스를 위한 프로토타입 객체를 정의, 새 인스턴스 생성 및 초기화 하는 함수
- this : 메서드의 호출 대상 객체를 가리킨다

# 2. 클래스와 생성자
- 생성자 호출의 핵심적인 특징은 생성자의 prototype 프로퍼티가 새 객체의 프로토타입으로 사용된다는 것이다.
- 모든 객체가 프로토타입 객체를 상속하려면, 프로퍼티 이름은 반드시 "prototype"이어야 한다.
- 생성자를 호출하면 새 객체는 자동으로 생성되고, 새 객체의 메서드로서 생성자 함수가 호출된 다음, 초기화 완료된 새 객체가 반환된다.
- 서로 다른 두 생성자 함수라도 같은 프로토타입 객체를 가리키는 prototype 프로퍼티를 가질 수 있다.
- 모든 자바스크립트 함수는 생성자로 사용될 수 있는데, 함수가 생성자로 호출되려면 prototype 프로퍼티가 있어야 한다. 따라서 모든 JS 함수에는 자동으로 prototype 프로퍼티가 설정된다. 이 prototype 프로퍼티의 값은 constructor 프로퍼티 하나만 가진 객체이다.
- constructor 프로퍼티는 열거되지 않으며 constructor 프로퍼티 값은 해당 함수 객체이다.
- 모든 함수에 대해 F.prototype.constructor == F 는 true이다.
- 미리 정의된 프로토타입 객체가 있고 이 프로토타입 객체가 constructor 프로퍼티를 가지고 있다는 말은, 일반적으로 어떤 객체가 자기 자신의 생성자를 가리키는 constructor 프로퍼티 또한 상속하고 있음을 뜻한다. 따라서 생성자는 클래스를 구별하는데 사용될 수 있고, constructor 프로퍼티를 통해 객체의 클래스를 얻을 수 있다.

# 3. 자바 스타일 클래스
- 생성자 객체: 생성자 함수(객체)는 클래스 이름을 정의한다.
- 프로토타입 객체: 이 객체의 프로퍼티는 클래스의 모든 인스턴스에 상속된다. 그리고 그 값이 함수인 프로퍼티는 인스턴스 메서드로 동작한다.
- 인스턴스 객체: 각 인스턴스는 독립적인 객체이고, 인스턴스에 직접 정의한 프로퍼티는 다른 인스턴스에 공유되지 않는다. 함수가 아닌 프로퍼티는 클래스의 인스턴스 필드로 작동한다.

# 4. 클래스 확장하기
- 자바스크립트 객체의 프로토타입에 메서드를 추가함으로써 간단히 JS 클래스를 확장할 수 있다.
- 그냥 Object.prototype에 프로퍼티를 추가하면, 이 프로퍼티는 모든 for/in 루프에서 열거된다. 안전한 확장을 위해서는 Object.defineProperty() 메서드를 사용하는 것이 좋다.
- 호스트 환경에서 정의된 클래스의 확장 여부는 호스트 환경의 구현체마다 다르다.

# 5. 클래스와 자료형
- instanceof 연산자는 생성자 함수를 요구하지만, 실제로 instanceof 연산자는 객체가 어떤 프로토타입을 상속했는지를 검사한다.
- isPrototype() 메서드를 통해 어떤 객체의 프로토타입 체인에 특별한 프로토타입 객체가 있는지를 검사할 수 있다.
- instanceof 연산자와 isPrototypeOf() 메서드의 단점은 오직 주어진 객체와 클래스의 관계만 테스트할뿐, 어떤 객체의 클래스가 무엇인지 알아내는 데 사용할 수 없다는 것이다.
- constructor 프로퍼티: constructor 프로퍼티를 통해 클래스 구분이 가능하다. 자바스크립트 객체 가운데는 constructor 프로퍼티가 없는 것도 있을 수 있다.
- 생성자 이름(Object.constructor.getName())
- 덕 타이핑(Duck-Typing): 만약 어떤 객체가 오리처럼 걷고 헤엄치고 꽥꽥거릴 수 있다면, 오리 클래스의 프로토타입 객체를 상속하지 않았더라도 그 객체를 오리로 취급할 수 있다. 일반적으로 덕 타이핑이라고 하는 것은 객체가 어떤 메서드들을 구현하고 있는지 테스트하는 것이다.
- 무간섭주의: 입력 객체가 메서드를 실제로 구현하고 있는지 검사하지 않는 것

# 6. 자바스크립트의 객체 지향 기법
- set: 중복되지 않은 값을 정렬되지 않은 형태로 저장하는 데이터 구조
- 표준변환 메서드
    - toString() : 객체의 문자열 표현을 반환
    - toLocaleString() : 객체를 로케일에 맞는 문자열로 변환
    - valueOf() : 객체를 원시 값으로 반환
    - toJSON() : JSON.stringify() 에 의해 자동 호출

- 비교 메서드
    - 자바스크립트의 동치 연산자들은 객체를 비교할 때, 값이 아니라 참조를 사용한다.
    - 이런 연산자들은 두 객체에, 이름이 같고 값도 같은 프로퍼티가 존재하는지를 검사하지 않는다.
    - compareTo() 메서드는 하나의 인자를 받고, 메서드 호출 대상 객체와 인자를 비교한다.

- 메서드 빌려오기
    - 메서드는 단순히 객체의 프로퍼티로 할당된 함수일 뿐이며, 객체를 '통해' 또는 객체를 '대상'으로 호출될 따름이다.

- private 상태
    - private 필드는 오직 인스턴스 메서드로만 접근할 수 있고 클래스의 외부에는 보이지 않는다.
    - 인스턴스를 생성할 때, 생성자 호출의 클로저에 포착된 변수(혹은 인자)를 사용하면 private 인스턴스 필드를 흉내낼 수 있다.
    - 캡슐화 기법에는 오버헤드가 있다. 상태를 캡슐화하도록 클로저를 사용하는 클래스는 그렇지 않은 클래스보다 확실히 느리고 크다.
    
# 7. 서브클래스
- 클래스A(superclass) -- extend --> 클래스B(subclass)
- 메서드 체이닝: 클래스B의 메서드가 클래스A의 메서드를 재정의했을 때, 클래스B의 재정의된 메서드에서 클래스A의 원래 메서드를 호출하는 것
- 생성자 체이닝: 서브클래스의 생성자B()가 슈퍼클래스의 생성자A()를 호출
- 추상 클래스: 실제로는 구현되지 않은 추상 메서드가 하나 이상 있는 클래스. 추상 메서드의 실제 구현은 추상 클래스를 상속한 서브 클래스가 담당함.
- JS의 객체는 클래스의 프로토타입 객체로부터 프로퍼티(보통 메서드)를 상속한다.
- singletonSet은 읽기 전용이고, 하나의 상수 멤버만 가진 특별한 집합이다.
- 서브클래스를 정의할 때, 메서드를 완전히 교체하지 않고 확장하거나 수정하고 싶을 때를 위해 체이닝이 필요하다.

# 8. ECMAScript 5 클래스
- Object.preventExtensions()는 객체를 확장할 수 없게 하는데, 이는 해당 객체에 새로운 프로퍼티가 추가될 수 없다는 뜻이다.
- Object.seal()은 새로운 프로퍼티가 추가되는 것을 막을 뿐만 아니라, 현재 객체에 있는 모든 프로퍼티를 재설정될 수 없게 한다.
- Object.freeze()는 Object.seal()의 모든 과정을 수행하고 추가로 모든 프로퍼티를 읽기 전용으로 설정하여 또한 재설정할 수 없도록 만든다.
- 인스턴스 메서드를 읽기 전용으로 만든다면, 서브클래스에서 재정의하기 훨씬 더 어려워진다.

# 9. 모듈
- 코드를 클래스로 구성하는 중요한 이유 중 하나는 코드를 더욱 모듈화하여 여러 상황에서 재사용하기 적합하게 하는 것이다.
- 모듈은 JS 코드로 이루어진 하나의 파일
- 모듈은 전역 실행 환경을 수정해서는 안되고, 뒤따르는 모듈이 간섭 없는(또는 간섭을 거의 받지 않는) 환경에서 실행되도록 해야 한다.
- 각 모듈은 전역 심볼을 최소한으로 정의해야 하며, 이상적으로는 단 하나의 전역 심볼도 정의하지 않아야 한다.
